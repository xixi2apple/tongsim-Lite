// Fill out your copyright notice in the Description page of Project Settings.


#include "TongSimGameplayFunc.h"

#include "EnhancedInputSubsystems.h"
#include "IHeadMountedDisplay.h"
#include "IXRTrackingSystem.h"
#include "SocketSubsystem.h"
#include "TSGameplaySettings.h"
#include "TSLogChannels.h"
#include "Core/TSCommandLineParams.h"
#include "GameModes/TSWorldSettings.h"
#include "Kismet/GameplayStatics.h"
#include "Materials/MaterialInstanceConstant.h"
#include "Player/TSPlayerStateBase.h"

FName UTongSimGameplayFunc::GetGUIDNameForUObject(TSubclassOf<UObject> ObjectClass)
{
	if (ObjectClass)
	{
		return FName(ObjectClass->GetFName().ToString() + FGuid::NewGuid().ToString());
	}
	return FName(FString("None") + FGuid::NewGuid().ToString());
}

UActorComponent* UTongSimGameplayFunc::AddComponentOnActorInstance(AActor* ActorInstance, TSubclassOf<UActorComponent> ComponentClass,
                                                                   bool bAddUnique, bool bAddIfNotChild, bool bUseAutoGeneratedName)
{
	if (!ActorInstance || !ComponentClass)
	{
		return nullptr;
	}
	if (!ComponentClass->GetDefaultObject<UActorComponent>()->GetIsReplicated() || ActorInstance->GetLocalRole() == ROLE_Authority)
	{
		// If AddUnique is set, it will be added only if no component on ActorInstance is child (or same class) of ComponentClass
		if (bAddUnique)
		{
			if (ActorInstance->GetComponentByClass(ComponentClass))
			{
				return nullptr;
			}
		}

		// If AddIfNotChild is set,it will be added only if ComponentClass is not a child (or same class) of an existing component on ActorInstance
		if (bAddIfNotChild)
		{
			const TSet<UActorComponent*>& Components = ActorInstance->GetComponents();
			for (const UActorComponent* ActorComp : Components)
			{
				if (ComponentClass->IsChildOf(ActorComp->GetClass()))
				{
					return nullptr;
				}
			}
		}

		// If UseAutoGeneratedName is set, it will generate a new name and not re-use the class name directly (which can lead to component recycling)
		const FName NewComponentName = bUseAutoGeneratedName ? NAME_None : ComponentClass->GetFName();

		UActorComponent* NewComp = NewObject<UActorComponent>(ActorInstance, ComponentClass, NewComponentName);
		if (USceneComponent* NewSceneComp = Cast<USceneComponent>(NewComp))
		{
			NewSceneComp->SetupAttachment(ActorInstance->GetRootComponent());
		}
		NewComp->RegisterComponent();
		UE_LOG(LogTongSimCore, Log, TEXT("Dynamic add a new component %s to actor %s."), *GetNameSafe(NewComp), *GetNameSafe(ActorInstance));
		return NewComp;
	}

	return nullptr;
}

bool UTongSimGameplayFunc::DestroyInstancedComponent(UActorComponent* Component)
{
	if (Component)
	{
		Component->DestroyComponent();
		Component->SetFlags(RF_Transient);
		return true;
	}
	return false;
}

ATSWorldSettings* UTongSimGameplayFunc::GetTongSimWorldSettings(UObject* WorldContextObject)
{
	if (WorldContextObject)
	{
		if (UWorld* World = WorldContextObject->GetWorld())
		{
			return Cast<ATSWorldSettings>(World->GetWorldSettings());
		}
	}
	return nullptr;
}


void UTongSimGameplayFunc::SimulateEnhancedInputAction(APlayerController* InPC, const UInputAction* InputAction, const FInputActionValue Value)
{
	if (InPC && InputAction)
	{
		if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(InPC->GetLocalPlayer()))
		{
			if (UEnhancedPlayerInput* PlayerInput = Subsystem->GetPlayerInput())
			{
				PlayerInput->InjectInputForAction(InputAction, Value);
			}
		}
	}
}

bool UTongSimGameplayFunc::IsHMDConnected()
{
#if PLATFORM_WINDOWS
	return GEngine->XRSystem.IsValid() && GEngine->XRSystem->GetHMDDevice() && GEngine->XRSystem->GetHMDDevice()->IsHMDConnected();
#else
	return false;
#endif
}


FString UTongSimGameplayFunc::GetLocalIP()
{
	bool CanBind = false;
	ISocketSubsystem* SocketSubsystem = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM);
	if (SocketSubsystem)
	{
		TSharedRef<FInternetAddr> LocalIPAddr = SocketSubsystem->GetLocalHostAddr(*GLog, CanBind);
		return LocalIPAddr->ToString(false);
	}
	return "";
}

bool UTongSimGameplayFunc::IsClientReady(const UObject* Context)
{
	if (Context)
	{
		// refer to UEngine::TickWorldTravel
		if (UWorld* World = Context->GetWorld())
		{
			if (AGameModeBase* GameModeBase = World->GetAuthGameMode())
			{
				return false;
			}

			if (FWorldContext* WorldContext = GEngine->GetWorldContextFromWorld(World))
			{
				if (WorldContext->TravelURL.IsEmpty())
				{
					if (World->HasBegunPlay() && World->GetNetMode() == NM_Client)
					{
						// TODO:
						if (APlayerController* PC = World->GetGameInstance()->GetFirstLocalPlayerController())
						{
							if (ATSPlayerStateBase* PS = PC->GetPlayerState<ATSPlayerStateBase>())
							{
								if (PS->GetPlayerType() != ETSPlayerType::Inactive)
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

bool UTongSimGameplayFunc::IsLocalDistributedAgent(const AActor* Agent)
{
	if (!Agent)
	{
		return false;
	}
	if (const APlayerController* PC = UGameplayStatics::GetPlayerController(Agent, 0))
	{
		if (ATSPlayerStateBase* PS = PC->GetPlayerState<ATSPlayerStateBase>())
		{
			if (PS->OwnAgent(Agent))
			{
				return true;
			}
		}
	}
	return false;
}

void UTongSimGameplayFunc::KickAllPlayer(const UObject* Context)
{
	if (!Context)
	{
		return;
	}

	UWorld* World = Context->GetWorld();
	if (!World || World->GetNetMode() == NM_Client)
	{
		return;
	}

	UE_LOG(LogTongSimCore, Log, TEXT("Kick all player from server."));
	APlayerController* Controller = NULL;
	FConstPlayerControllerIterator Iterator = World->GetPlayerControllerIterator();
	for(; Iterator; ++Iterator)
	{
		Controller = Iterator->Get();
		if (Controller && !Controller->IsLocalPlayerController() && Controller->IsPrimaryPlayer())
		{
			// Clients
			Controller->ClientReturnToMainMenuWithTextReason(NSLOCTEXT("NetworkErrors", "HostKickAll", "Host kicked all client."));
		}
	}
}

void UTongSimGameplayFunc::GetViewFrustumVolume(FMatrix ViewProjectionMatrix, FConvexVolume& OutFrustum)
{
	OutFrustum.Planes.Empty(6);
	FPlane Temp;

	// Near clipping plane.
	if (ViewProjectionMatrix.GetFrustumNearPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	// Left clipping plane.
	if (ViewProjectionMatrix.GetFrustumLeftPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	// Right clipping plane.
	if (ViewProjectionMatrix.GetFrustumRightPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	// Top clipping plane.
	if (ViewProjectionMatrix.GetFrustumTopPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	// Bottom clipping plane.
	if (ViewProjectionMatrix.GetFrustumBottomPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	// Far clipping plane.
	if (ViewProjectionMatrix.GetFrustumFarPlane(Temp))
	{
		OutFrustum.Planes.Add(Temp);
	}

	OutFrustum.Init();
}

void UTongSimGameplayFunc::GetActorsInViewFrustumWithAABBCulling(FMinimalViewInfo ViewInfo, int32 DepthBufferWidth, int32 DepthBufferHeight, const TArray<AActor*>& InActors, TArray<AActor*>& OutActors)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(TongSim_GetActorsInViewFrustumWithAABBCulling)

	// Initialize parameters:
	OutActors.Reset();

	FMatrix ViewMatrix;
	FMatrix ProjectionMatrix;
	FMatrix ViewProjectionMatrix;
	UGameplayStatics::GetViewProjectionMatrix(ViewInfo, ViewMatrix, ProjectionMatrix, ViewProjectionMatrix);

	const FVector CameraLocation = ViewInfo.Location;

	struct FActorAABBCullingData
	{
		AActor* ActorPtr = nullptr;
		float SquareDistance = 0.f;
		FBox ActorAABB;

		FActorAABBCullingData(AActor* InActorPtr, float InSquareDistance, const FBox& InActorAABB) : ActorPtr(InActorPtr), SquareDistance(InSquareDistance), ActorAABB(InActorAABB)
		{
		}
	};

	// View frustum culling
	FConvexVolume Frustum;
	GetViewFrustumVolume(ViewProjectionMatrix, Frustum);
	TArray<FActorAABBCullingData> ActorsInFrustum;
	for (AActor* Actor : InActors)
	{
		if (Actor)
		{
			const FBox AABB = Actor->GetComponentsBoundingBox();
			if (Frustum.IntersectBox(AABB.GetCenter(), AABB.GetExtent()))
			{
				const float DistSquared = FVector::DistSquared(CameraLocation, AABB.GetCenter());
				ActorsInFrustum.Emplace(FActorAABBCullingData(Actor, DistSquared, AABB));

				if (const UTSGameplaySettings* GameSettings = GetDefault<UTSGameplaySettings>())
				{
					if (GameSettings->bCullingWithLineTrace)
					{
						// LineTrace
						TArray<AActor*> ActorsToIgnore;
						FHitResult Result;
						bool bHit = UKismetSystemLibrary::LineTraceSingle(Actor, CameraLocation, AABB.GetCenter(), UEngineTypes::ConvertToTraceType(ECollisionChannel::ECC_Camera), false, ActorsToIgnore,
						                                                  EDrawDebugTrace::None, Result, false);

						if (bHit)
						{
							if (Result.GetActor() == Actor)
							{
								OutActors.Emplace(Actor);
							}
						}
					}
				}

				// DrawDebugBox(Actor->GetWorld(), AABB.GetCenter(), AABB.GetExtent(), FColor::Cyan, true, -1, 0, 1.f);
			}
		}
	}


	// Project AABB box to view lambda:
	const auto ProjectAABBToScreen = [&](const FBox& InAABB, UE::Math::TBox2<float>& OutBox)
	{
		// Init, TODO by wukunlun: remove this?
		OutBox.Min = UE::Math::TVector2<float>(0, 0);
		OutBox.Max = UE::Math::TVector2<float>(0, 0);
		OutBox.bIsValid = false;

		FVector Vertices[8];
		InAABB.GetVertices(Vertices);

		for (FVector WorldPos : Vertices)
		{
			UE::Math::TVector2<float> GripPos;

			FPlane Result = ViewProjectionMatrix.TransformFVector4(FVector4(WorldPos, 1.f));
			if (Result.W > 0.0f)
			{
				// the result of this will be x and y coords in -1..1 projection space
				const float RHW = 1.0f / Result.W;
				FPlane PosInScreenSpace = FPlane(Result.X * RHW, Result.Y * RHW, Result.Z * RHW, Result.W);

				// Move from projection space to normalized 0..1 UI space
				const float NormalizedX = (PosInScreenSpace.X / 2.f) + 0.5f;
				const float NormalizedY = 1.f - (PosInScreenSpace.Y / 2.f) - 0.5f;

				GripPos.X = FMath::Clamp(static_cast<int>(NormalizedX * static_cast<float>(DepthBufferWidth)), 0, DepthBufferWidth - 1);
				GripPos.Y = FMath::Clamp(static_cast<int>(NormalizedY * static_cast<float>(DepthBufferHeight)), 0, DepthBufferHeight - 1);

				OutBox += GripPos;
			}
		}
	};

	// Sorted by distance, near to far
	ActorsInFrustum.Sort([](const FActorAABBCullingData& A, const FActorAABBCullingData& B)
	{
		return A.SquareDistance < B.SquareDistance;
	});

	// Culling with AABB:
	TArray<float> DepthBuffer;
	TArray<AActor*> ActorPtrBuffer;
	DepthBuffer.Init(MAX_FLT, DepthBufferWidth * DepthBufferHeight);
	ActorPtrBuffer.Init(nullptr, DepthBufferWidth * DepthBufferHeight);

	for (const FActorAABBCullingData& ActorAABBCullingData : ActorsInFrustum)
	{
		UE::Math::TBox2<float> ScreenBox;
		ProjectAABBToScreen(ActorAABBCullingData.ActorAABB, ScreenBox);

		const int32 MinX = static_cast<int>(ScreenBox.Min.X);
		const int32 MinY = static_cast<int>(ScreenBox.Min.Y);
		const int32 MaxX = static_cast<int>(ScreenBox.Max.X);
		const int32 MaxY = static_cast<int>(ScreenBox.Max.Y);
		for (int32 X = MinX; X <= MaxX; ++X)
		{
			for (int32 Y = MinY; Y <= MaxY; ++Y)
			{
				const int32 PixelIndex = Y * DepthBufferWidth + X;
				if (ActorAABBCullingData.SquareDistance < DepthBuffer[PixelIndex])
				{
					DepthBuffer[PixelIndex] = ActorAABBCullingData.SquareDistance;
					ActorPtrBuffer[PixelIndex] = ActorAABBCullingData.ActorPtr;
				}
			}
		}
	}

	for (int32 PixelIndex = 0; PixelIndex < DepthBufferWidth * DepthBufferHeight; ++PixelIndex)
	{
		if (ActorPtrBuffer[PixelIndex])
		{
			OutActors.AddUnique(ActorPtrBuffer[PixelIndex]);
		}
	}
}

bool UTongSimGameplayFunc::HighlightMesh(UMeshComponent* Mesh, bool bHighlight, float LineThickness, FLinearColor Color)
{
	if (Mesh)
	{
		if (bHighlight)
		{
			// TODO:
			UMaterialInstanceConstant* MaterialInstanceConstant = Cast<UMaterialInstanceConstant>(
				StaticLoadObject(UMaterialInstanceConstant::StaticClass(), nullptr, TEXT("/TongSimCore/Gameplay/OutlineFX/MT_I_OUTLINER.MT_I_OUTLINER"))
			);

			if (MaterialInstanceConstant)
			{
				UMaterialInstanceDynamic* DynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialInstanceConstant, Mesh);

				if (DynamicMaterialInstance)
				{
					DynamicMaterialInstance->SetVectorParameterValue(FName("Color"), FLinearColor(Color));
					DynamicMaterialInstance->SetScalarParameterValue(FName("Thickness"), LineThickness);
					constexpr uint8 CustomDepthStencilValue = 2; // Material constant

					Mesh->SetOverlayMaterial(DynamicMaterialInstance);
					Mesh->SetCustomDepthStencilValue(CustomDepthStencilValue);
					Mesh->SetRenderCustomDepth(true);

					return true;
				}
			}
		}
		else
		{
			Mesh->SetOverlayMaterial(nullptr);
			Mesh->SetCustomDepthStencilValue(0);
			Mesh->SetRenderCustomDepth(false);
		}
	}
	return false;
}
